#include <iostream>
#include <fstream>
#include <string>
#include <memory>
#include <vector>
#include <map>
#include "stdlib.h"
#include <algorithm>
#include "dictionary.h"
#include "tree.h"

using namespace std;


	
template <class T>
void print(T& t){
	t.print();
}	
		
char* CStyleFileRead(const char* filepath, int* _fsize ){
	
	FILE* file = fopen(filepath,"rb");
	fseek(file,0,SEEK_END);
	long fsize=ftell(file);
	rewind(file);
	char* buf= (char*) malloc(fsize);	
	size_t result=fread(buf,1, fsize,file);
	*_fsize=result;
	printf("%i \n",result);
		
	return buf;
}

string* CppStyleFileRead(const char* filepath){
	
	static std::string* str=new std::string(
	(std::istreambuf_iterator<char>
	(*(std::auto_ptr<std::ifstream>(new std::ifstream(filepath)))
	.get())),
    std::istreambuf_iterator<char>());
	return str;		
}

//struct word{
//	char _word;
//	int  wcount;
//	int  vpos;
//	word(char w, int c){
//		_word=w;
//		wcount=c;
//	};
//};

void createDic(map<char,int>& dic,map<char,int>::iterator& itm, string* str){
			
			
		string::iterator it=str->begin();		
		for(;it!=str->end();++it){		
			string buf(str->begin(),it);			
			if(buf.find(*it)==(-1)){
				dic.insert(itm,pair<int,int>(*it,1));	
				
			}else{
				dic[*it]++;
				
			}			
		}
		itm=dic.begin();
}

string toBinary(int s){
	string str;
	while(s){
		if(s%2){
			str+="1";
		}else{
			str+="0";
		}
		s/=2;
	}
	return str;
}

template <typename A, typename B>
pair<B,A> flip_pair(const pair<A,B>& p){
	return pair<B,A>(p.second,p.first);
}

template <typename A, typename B>
map<B,A> flip_map(const map<A,B>& _map){
	
	map<B,A> dst;
	
	transform(_map.begin(),_map.end(),inserter(dst,dst.begin()),flip_pair<A,B>);
	return dst;
}


int main(int argc, char** argv) {
	
	map<char,int> dic;
	map<char,int>::iterator it=dic.begin();

	
	string* str= new string("wwwwwwwqqqaaaaxxxqqg");		
	createDic(dic,it,CppStyleFileRead("matrix.exe"));
//	createDic(dic,it,str);
	dictionary* d= new dictionary(dic,dic.size());
	tree* t= new tree(*d);
	
	t->printTree();
	cout<<"-----------------------------"<<endl;
	t->printNode(t->getSize()-1);
	
	
	
	
	
	delete str;
	delete d;
	delete t;
	
	return 0;
}
#ifndef TREE_H
#define TREE_H
#include <map>
#include "node.h"
#include "dictionary.h"

using namespace std;


class tree
{
	
	node* _tree;
	node* root;
	int size;	
	void init(word* w, int wsize);
	void createTree(int i,int& left, int wsize );	
	public:
		tree(dictionary& dic);
		~tree();
		
		void printNode(int n);
		void printTree();
		node* getRoot() const;
		int getSize()const;
	
};

#endif
#include "tree.h"

tree::tree(dictionary& dic){
	size=dic.getSize();
	init(dic.getWord(),size);	
}

tree::~tree(){
	delete[] _tree;
}

void tree::init(word* w, int wsize){
	
	int m= (wsize%2)? 0 : -1;
	size = wsize*2+m;
	_tree=new node[size];
	//построение дерева
	int left=0,right;
	int lleft=wsize;
	
	for(int i=0;i<size;++i){
		
		if((i>=wsize)){
//			 right=left+1;
						
//			if(_tree[left].getWeight()<=_tree[right].getWeight()){
				createTree(i,left,0);							
//			}
				if(i>=(wsize+wsize/2)){					
					createTree(i,lleft,wsize);
//					cout<<_tree[i].toString()<<" "<<_tree[i].getWeight()<<endl;
				}
		}else{
			_tree[i]= &w[i];			
		}
			
	}
	

}


void tree::printNode(int n){
	cout<<_tree[n].toString();
}

void tree::printTree(){
	int count=0;
	for(int i=0;i<size;++i){
		
		if((_tree[i].getLnextNode()!=0)&&(_tree[i].getRnextNode()!=0)){
			cout<<_tree[i].getLnextNode()->toString()<<" "<<_tree[i].getLnextNode()->getWeight()<<endl;
			cout<<"\t\t"<<_tree[i].getRnextNode()->toString()<<" "<<_tree[i].getRnextNode()->getWeight()<<endl;
			++count;	
		}else{
			cout<<_tree[i].toString()<<" "<<_tree[i].getWeight()<<endl;		
		}
	}
	cout<<"count: "<<count<<endl;
}

void tree::createTree(int i,int& left, int wsize){

	
	if((wsize+left)!=size){
	int right=left+1;
		_tree[i]=_tree[wsize+left]+_tree[wsize+right];
				
				_tree[i].setLNext(&_tree[wsize+left]);
				_tree[i].setRNext(&_tree[wsize+right]);
								
				_tree[wsize+left].writeBit(true);
				_tree[wsize+right].writeBit(false);
				
				left+=2;
				
		
	}
	
}

node* tree::getRoot()const{
	return this->root;
}

int tree::getSize()const{
	return this->size;
}
#ifndef NODE_H
#define NODE_H
#include <string>
#include <vector>
#include "word.h"

using namespace std;

class node
{
	bool indexNode;	
	node* lnext;
	node* rnext;
	vector<char> symbol;
	int weight;
	public:		
		node(word* w);
		node();
		~node();		
		
		string toString() const;
		node* getLnextNode() const;
		node* getRnextNode() const;
		bool getIndexNode() const;
		int getWeight()const;
		
		void setLNext(node* n);
		void setRNext(node* n);
		void writeBit(bool b);
		void setChar(char* s);
		
		node operator+(const node& n);

};

#endif
#include "node.h"

node::node(word* w):lnext(0),rnext(0){
	symbol.push_back(w->wsymbol);
	weight=w->wcount;
}
node::node(){
}


node::~node(){
	
}

node* node::getLnextNode() const{
	return this->lnext;
}
node* node::getRnextNode() const{
	return this->rnext;
}

void node::setLNext(node* n){
	this->lnext=n;
}

void node::setRNext(node* n){
	this->rnext=n;
}

void node::writeBit(bool b){
	
	this->indexNode=b;
}

bool node::getIndexNode()const{
	return this->indexNode;
}
string node::toString()const{
		
		string str;
		for(int i=0;i<symbol.size();++i){
			str+=symbol[i];
		}
		return str;
}

void node::setChar(char* s){
	this->symbol.push_back(*s);
}

node node::operator+(const node& n){
	
	node m;
	vector<char> buf=this->symbol;
	m.weight=this->weight+n.weight;
	for(int i=0;i<n.symbol.size();++i){
		buf.push_back(n.symbol[i]);
	}
	m.symbol=buf;
	return m;
	
}

int node::getWeight()const{
	return this->weight;
}
#ifndef DICTIONARY_H
#define DICTIONARY_H

#include <map>
#include <iostream>
#include "word.h"

using namespace std;
	
class dictionary
{
	word* _word;		
	void quickSort (word* a, int l,int r);
	const int size;
	
	public:
		dictionary(map<char,int>& _dic,int dsize);
		word* getWord();
		int   getSize();
		~dictionary();
	
};

#endif
#include "dictionary.h"

dictionary::dictionary(map<char,int>& _dic,int dsize):size(dsize){
	
	 
	_word= new word[size];
	map<char,int>::iterator it=_dic.begin();
	int i=0;
	for(it=_dic.begin();it!=_dic.end();++it){	
		if(i!=size)	{
			_word[i].wsymbol=it->first;
			_word[i].wcount=it->second;			
			++i;
			
			}
		}
		quickSort(_word,0,size);	
}

dictionary::~dictionary(){

	delete[] _word;
}

word* dictionary::getWord(){
	return this->_word;
}
int dictionary::getSize(){
	return size;
}

 void dictionary::quickSort (word* a, int l,int r){
	
	int left=l;
	int right=r;
	int middle=a[(right+left)/2].wcount;
	word temp;
	
		while(left<=right){
			
		while((a[left].wcount<middle) && (left<=right))left++;
		
		while((a[right].wcount>middle) && (right>=left))right--;
		
		if(left<=right){
			temp=a[left];
			a[left]=a[right];
			a[right]=temp;
			left++;right--;
		}
	}
	if(right>l){
		quickSort(a,l,right);
	}
	if(left<r){
		quickSort(a,left,r);
	}
	
	
}
